#include "sepr.hpp"
#include "device/deviceConnection.hpp"
#include "device/device.hpp"
#include "chips/memory/rom.hpp"
#include "chips/memory/ram.hpp"
#include "chips/register.hpp"
#include "chips/opcode.hpp"
#include "chips/cpu/cpu.hpp"
#include "chips/cpu/mos/6502/6502.hpp"
#include "systems/system.hpp"
#include "io/port/port.hpp"
#include "io/drive.hpp"
#include "io/disk_drives/disk_drive.hpp"
#include "chips/interfaceAdapter/mos/6526.hpp"

#include "1541-II.hpp"

void cVia1_SerialPort::pinUpdate() {
    bool lineAtn;

    lineAtn = mLineAtn;

    mLineAtn = 1;
    if (ciaAtnIsOutput) 
        mLineAtn &= ciaAtnPin;

    mLineClock = 1;
    if (ciaClockIsOutput) 
        mLineClock &= ciaClockPin;

    if (deviceClockIsOutput) 
        mLineClock &= deviceClockPin;
        
    mLineData = 1;
    if (ciaDataIsOutput) 
        mLineData &= ciaDataPin;

    if (deviceDataIsOutput) 
        mLineData &= deviceDataPin;

    // Auto Ack
    if (deviceAtnPin == 1)
            mLineData &= mLineAtn;
        
    // Check atn line for a negative edge
    if (lineAtn == 1 && mLineAtn == 0) {

        ((cVia1*) mParent)->flagAtnSet();
        mParent->mSystemGet<cDrive_Commodore_1541_II>()->interruptAdd("ATN", this);

    }
}

void cVia1_SerialPort::pinsCiaUpdate( byte pValue, byte pDirection ) {
    
    ciaAtnIsOutput  = (pDirection & 0x08) ? 1 : 0;
    ciaClockIsOutput= (pDirection & 0x10) ? 1 : 0;
    ciaDataIsOutput = (pDirection & 0x20) ? 1 : 0;
    ciaAtnPin       = (pValue & 0x08) ? 0 : 1;          //   Inverted
    ciaClockPin     = (pValue & 0x10) ? 0 : 1;          //   Inverted
    ciaDataPin      = (pValue & 0x20) ? 0 : 1;          //   Inverted

    pinUpdate();
}

void cVia1_SerialPort::pinsViaUpdate( byte pValue, byte pDirection ) {

    deviceAtnIsOutput   = (pDirection & 0x10) ? 1 : 0;
    deviceClockIsOutput = (pDirection & 0x08) ? 1 : 0;
    deviceDataIsOutput  = (pDirection & 0x02) ? 1 : 0;
    deviceAtnPin        = (pValue & 0x10) ? 0 : 1;      //   Inverted
    deviceClockPin      = (pValue & 0x08) ? 0 : 1;      //   Inverted
    deviceDataPin       = (pValue & 0x02) ? 0 : 1;      //   Inverted
       
    pinUpdate();
}

cVia1::cVia1(cSepr *pSepr, cSystem *pSystem, cDevice *pDevice ) : cVia_Mos_6522( "VIA1", pSepr, pSystem, pDevice ) {

    mPortB = new cVia1_SerialPort( pSepr, pSystem, this );
}

	byte cVia1::busReadByte( size_t pAddress ) {

		switch( pAddress & 0x0F ) {

			case 0x00:		// Port B: serial port
				 byte result, pins;
                        // Bit 0: Data in    0x01
                        // Bit 1: Data out   0x02
                        // Bit 2: Clock in   0x04
                        // Bit 3: Clock out  0x08
                        // Bit 4: ATN out    0x10
                        // Bit 5:            0x20
                        // Bit 6:            0x40
                        // Bit 7: ATN in     0x80
                        pins = 
                                (mPortBGet()->lineData()  ? 0x00 : 0x01) |
                                (mPortBGet()->lineClock() ? 0x00 : 0x04) |     
                                (mPortBGet()->lineAtn()   ? 0x00 : 0x80);   

                        result = (mDataDirectionPortB & mDataB) | (~mDataDirectionPortB & pins);                                                                      
                        return (result & 0x9F); // Force Device Address 0

			case 0x01:		// Port A. Read will acknowledge interrupt generated by ATN IN going high.
			    flagAtnClear();
                mSystem->interruptRemove("VIA1_ATN");
				return mDataA;
		}

		return cVia_Mos_6522::busReadByte( pAddress );
	}

	void cVia1::busWriteByte( size_t pAddress, byte pData ) {

		switch( pAddress & 0x0F ) {

			case 0x00:
				mInterruptFlags &= 0xF7;
                mInterruptFlags &= 0xEF; 

                mDataB = pData;
                mPortBGet()->pinsViaUpdate(pData, mDataDirectionPortB);
				return;
		
			case 0x01:
				mPortA->valueSet(pData);

                flagAtnClear();
                mInterruptFlags &= 0xFE; 
				mSystem->interruptRemove("VIA1_ATN");

                mDataA = pData;
				return;

            case 0x02:
                mDataDirectionPortB = pData;
                mPortBGet()->pinsViaUpdate(pData, mDataDirectionPortB);
                return;
		}

		return cVia_Mos_6522::busWriteByte( pAddress, pData );
	}